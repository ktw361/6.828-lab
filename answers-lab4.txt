Exercise 1 & 2:
    Questions answer:
        1. Since the mpentry.S code and loaded not linked, their address will start from zero, if not using MPBOOTPHYS.

Ex 3, 4, 5:
    Question
        2. One cpu modify kernel of another cpu, e.g. another cpu's Env.

Ex 6:
    Question
        3. Because e is allocated in envs, which is static mapped to same virtual address in every page directory.
        4. Each env's associated registers are Context of that env. Saving is done by _alltraps.

Ex 7:   Done

Part B:
Ex 8, 9, 10, 11:
    In ex10 , ONLY decrement tf->tf_esp by 4 when already in EXCEPTION.
    in pfentry.S, UTrapframe's fault_va and error_code is skipped (addl $8 %esp). Magic Number $40, $8 is calculated by watch the size of PushRegs and other parameters in UTrapframe(sizeof(UTrameframe) = 52, sizeof(PushRegs) = 8*4 = 32), push trap-time eip by modifying trap-time esp using assembly language.

Ex 12:
    UVPT 真的很聪明！！！
    巧妙之处在于把PDX指向到了自身，把PTX指向了原PDX，而offset呢，刚好又和uvpt[pn]的pn*4 的后12位对应上了，而且刚好32bit宽，我佛了！。。。。
    访问pt的permission位(即va), 只需uvpt[pn];访问pd的permission位，只需upvd[pn].
    va 的 page-aligned 真的很关键！(在pgfault)

Part C:
Ex13, 14:
    Note: run with CPUS more than 1, otherwise it will no pass read_eflags() assert in trap()
    修改 trap_init (lab3), 由于JOS diable interrupt in kernel mode，SETGATE for T_SYSCALL 应该是 0，interrupt gate 而不是trap gate.
    记得要 eoi lapic 的中断

Ex 15:
    修改: check of env_status in env_run(), caller modify env_status to ENV_NOT_RUNNABLE before call to env_run();
   ipc_send loops, and yield(); ipc_recv calls sys_ipc_recv, sys__ipc_recv block by sched_yield();
